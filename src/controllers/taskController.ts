import { Request, Response } from "express";
import { Task } from "../models/Task";
import { Project } from "../models/Project";
import { Recipe } from "../models/Recipe";
import { Product } from "../models/Product";
import { APIResponse, AuthenticatedRequest } from "../types";

export const getTasks = async (req: Request, res: Response): Promise<void> => {
  try {
    const {
      status,
      deviceId,
      projectId,
      recipeId,
      productId,
      workerId,
      page = 1,
      limit = 10
    } = req.query;

    const query: any = {};
    if (status) query.status = status;
    if (deviceId) query.deviceId = deviceId;
    if (projectId) query.projectId = projectId;
    if (recipeId) query.recipeId = recipeId;
    if (productId) query.productId = productId;
    if (workerId) query.workerId = workerId;

    const pageNum = parseInt(page as string);
    const limitNum = parseInt(limit as string);
    const skip = (pageNum - 1) * limitNum;

    const total = await Task.countDocuments(query);
    const tasks = await Task.find(query)
      .populate("projectId", "name status priority")
      .populate("workerId", "name username")
      .populate("recipeSnapshotId", "name version steps")
      .populate("productSnapshotId", "name version")
      .skip(skip)
      .limit(limitNum)
      .sort({ createdAt: -1 });

    const response: APIResponse = {
      success: true,
      message: "Tasks retrieved successfully",
      data: {
        items: tasks,
        pagination: {
          page: pageNum,
          limit: limitNum,
          total,
          totalPages: Math.ceil(total / limitNum),
          hasNext: pageNum * limitNum < total,
          hasPrev: pageNum > 1
        }
      }
    };

    res.json(response);
  } catch (error) {
    console.error("Get tasks error:", error);
    const response: APIResponse = {
      success: false,
      error: "INTERNAL_SERVER_ERROR",
      message: "Internal server error"
    };
    res.status(500).json(response);
  }
};

export const getTaskById = async (
  req: Request,
  res: Response
): Promise<void> => {
  try {
    const { id } = req.params;

    const task = await Task.findById(id)
      .populate("projectId")
      .populate("workerId", "name username")
      .populate("recipeSnapshotId", "name version steps")
      .populate("productSnapshotId", "name version");

    if (!task) {
      const response: APIResponse = {
        success: false,
        error: "NOT_FOUND",
        message: "Task not found"
      };
      res.status(404).json(response);
      return;
    }

    const response: APIResponse = {
      success: true,
      message: "Task retrieved successfully",
      data: task
    };

    res.json(response);
  } catch (error) {
    console.error("Get task error:", error);
    const response: APIResponse = {
      success: false,
      error: "INTERNAL_SERVER_ERROR",
      message: "Internal server error"
    };
    res.status(500).json(response);
  }
};

export const createTask = async (
  req: AuthenticatedRequest,
  res: Response
): Promise<void> => {
  try {
    const {
      title,
      description,
      projectId,
      recipeId,
      recipeStepId,
      deviceId,
      workerId,
      status,
      priority,
      estimatedDuration,
      notes,
      qualityData
    } = req.body;

    // Validation
    if (!title || !recipeId || !recipeStepId) {
      const response: APIResponse = {
        success: false,
        error: "VALIDATION_ERROR",
        message: "Title, recipeId, and recipeStepId are required"
      };
      res.status(400).json(response);
      return;
    }

    let recipeStep: any = null;
    let deviceTypeId: any = null;
    let taskEstimatedDuration: number | undefined = estimatedDuration;
    let recipeSnapshotId: any = null;
    let stepOrder: number = 1;
    let isLastStepInRecipe: boolean = false;

    // Check if this is a project task or standalone task
    if (projectId) {
      // PROJECT TASK: Should already have tasks generated by updateProject
      // This path is for manual task creation within existing projects
      const response: APIResponse = {
        success: false,
        error: "VALIDATION_ERROR",
        message:
          "Project tasks are auto-generated on project activation. Use standalone task creation instead."
      };
      res.status(400).json(response);
      return;
    } else {
      // STANDALONE TASK: Create snapshot and task
      const recipe = await Recipe.findById(recipeId);

      if (!recipe) {
        const response: APIResponse = {
          success: false,
          error: "NOT_FOUND",
          message: "Recipe not found"
        };
        res.status(404).json(response);
        return;
      }

      // Create recipe snapshot using SnapshotService
      const { SnapshotService } = await import("../services/snapshotService");
      const recipeSnapshot = await SnapshotService.getOrCreateRecipeSnapshot(
        recipeId
      );
      recipeSnapshotId = recipeSnapshot._id;

      // Find recipe step in snapshot
      recipeStep = recipeSnapshot.steps.find(
        (step: any) => step._id.toString() === recipeStepId
      );

      if (!recipeStep) {
        const response: APIResponse = {
          success: false,
          error: "NOT_FOUND",
          message: `Recipe step '${recipeStepId}' not found in recipe snapshot`
        };
        res.status(404).json(response);
        return;
      }

      deviceTypeId = recipeStep.deviceTypeId;
      taskEstimatedDuration = estimatedDuration || recipeStep.estimatedDuration;
      stepOrder = recipeStep.order;

      // Determine if this is the last step
      const maxStepOrder = Math.max(
        ...recipeSnapshot.steps.map((s: any) => s.order)
      );
      isLastStepInRecipe = stepOrder === maxStepOrder;
    }

    // Extract deviceTypeId from recipe step
    if (!deviceTypeId) {
      const response: APIResponse = {
        success: false,
        error: "VALIDATION_ERROR",
        message: "Recipe step does not have a deviceTypeId"
      };
      res.status(400).json(response);
      return;
    }

    // Create standalone task with execution tracking
    const task = new Task({
      title,
      description,
      projectId: undefined, // Standalone tasks have no projectId
      recipeId,
      productId: undefined,
      recipeSnapshotId,
      productSnapshotId: undefined,
      recipeStepId,
      recipeExecutionNumber: 1, // Standalone tasks are single execution
      totalRecipeExecutions: 1,
      stepOrder,
      isLastStepInRecipe,
      deviceTypeId,
      deviceId,
      workerId,
      status: status || "PENDING",
      priority: priority || "MEDIUM",
      estimatedDuration: taskEstimatedDuration,
      progress: 0,
      notes,
      qualityData,
      pausedDuration: 0
    });

    await task.save();
    await task.populate("workerId");

    const response: APIResponse = {
      success: true,
      message: "Standalone task created successfully",
      data: task
    };

    res.status(201).json(response);
  } catch (error: any) {
    console.error("Create task error:", error);
    const response: APIResponse = {
      success: false,
      error: "INTERNAL_SERVER_ERROR",
      message: error.message || "Internal server error"
    };
    res.status(500).json(response);
  }
};

export const updateTaskStatus = async (
  req: AuthenticatedRequest,
  res: Response
): Promise<void> => {
  try {
    const { id } = req.params;
    const { status, notes, startTime, endTime, progress } = req.body;

    const task = await Task.findById(id);

    if (!task) {
      const response: APIResponse = {
        success: false,
        error: "NOT_FOUND",
        message: "Task not found"
      };
      res.status(404).json(response);
      return;
    }

    if (status) task.status = status;
    if (notes) task.notes = notes;
    if (startTime) task.startedAt = new Date(startTime);
    if (endTime) task.completedAt = new Date(endTime);
    if (progress !== undefined) task.progress = progress;

    // Calculate actual duration if completed
    if (status === "COMPLETED" && task.startedAt && task.completedAt) {
      task.actualDuration = Math.floor(
        (task.completedAt.getTime() - task.startedAt.getTime()) / 60000
      );
    }

    await task.save();
    await task.populate("projectId workerId");

    const response: APIResponse = {
      success: true,
      message: "Task status updated successfully",
      data: task
    };

    res.json(response);
  } catch (error) {
    console.error("Update task status error:", error);
    const response: APIResponse = {
      success: false,
      error: "INTERNAL_SERVER_ERROR",
      message: "Internal server error"
    };
    res.status(500).json(response);
  }
};

export const deleteTask = async (
  req: AuthenticatedRequest,
  res: Response
): Promise<void> => {
  try {
    const { id } = req.params;

    const task = await Task.findByIdAndDelete(id);

    if (!task) {
      const response: APIResponse = {
        success: false,
        error: "NOT_FOUND",
        message: "Task not found"
      };
      res.status(404).json(response);
      return;
    }

    const response: APIResponse = {
      success: true,
      message: "Task deleted successfully"
    };

    res.json(response);
  } catch (error) {
    console.error("Delete task error:", error);
    const response: APIResponse = {
      success: false,
      error: "INTERNAL_SERVER_ERROR",
      message: "Internal server error"
    };
    res.status(500).json(response);
  }
};

/**
 * Complete a task and handle next step logic
 * POST /api/tasks/:id/complete
 */
export const completeTask = async (
  req: AuthenticatedRequest,
  res: Response
): Promise<void> => {
  try {
    const { id } = req.params;
    const { workerId, notes, qualityData, actualDuration } = req.body;

    // Find the task and populate snapshot
    const task = await Task.findById(id).populate("recipeSnapshotId");
    if (!task) {
      const response: APIResponse = {
        success: false,
        error: "NOT_FOUND",
        message: "Task not found"
      };
      res.status(404).json(response);
      return;
    }

    // Validate workerId
    if (!workerId && !task.workerId) {
      const response: APIResponse = {
        success: false,
        error: "VALIDATION_ERROR",
        message: "workerId is required to complete a task"
      };
      res.status(400).json(response);
      return;
    }

    // Validate that snapshot exists
    if (!task.recipeSnapshotId) {
      const response: APIResponse = {
        success: false,
        error: "VALIDATION_ERROR",
        message: "Task does not have a recipe snapshot reference"
      };
      res.status(400).json(response);
      return;
    }

    const recipeSnapshot = task.recipeSnapshotId as any;

    // Update task to COMPLETED
    task.status = "COMPLETED";
    task.workerId = workerId || task.workerId;
    task.completedAt = new Date();
    task.progress = 100;
    if (notes) task.notes = notes;
    if (qualityData) task.qualityData = qualityData;
    if (actualDuration) task.actualDuration = actualDuration;

    // Calculate actual duration if not provided
    if (!actualDuration && task.startedAt) {
      task.actualDuration = Math.floor(
        (task.completedAt.getTime() - task.startedAt.getTime()) / 60000
      );
    }

    await task.save();

    let nextTask = null;
    let project = null;

    // If NOT the last step, create next step task for SAME execution
    if (!task.isLastStepInRecipe) {
      // Find next step in snapshot by order
      const nextStep = recipeSnapshot.steps.find(
        (step: any) => step.order === task.stepOrder + 1
      );

      if (!nextStep) {
        const response: APIResponse = {
          success: false,
          error: "VALIDATION_ERROR",
          message: "Next step not found in recipe snapshot"
        };
        res.status(400).json(response);
        return;
      }

      // Validate deviceTypeId
      if (!nextStep.deviceTypeId) {
        const response: APIResponse = {
          success: false,
          error: "VALIDATION_ERROR",
          message: "Next recipe step does not have a deviceTypeId"
        };
        res.status(400).json(response);
        return;
      }

      // Determine if next step is the last step
      const maxStepOrder = Math.max(
        ...recipeSnapshot.steps.map((s: any) => s.order)
      );
      const isNextStepLast = nextStep.order === maxStepOrder;

      // Create next task for SAME execution
      nextTask = new Task({
        title: `${nextStep.name} - Exec ${task.recipeExecutionNumber}/${task.totalRecipeExecutions}`,
        description: nextStep.description,
        projectId: task.projectId || undefined,
        recipeId: task.recipeId,
        productId: task.productId,
        recipeSnapshotId: task.recipeSnapshotId,
        productSnapshotId: task.productSnapshotId,
        recipeStepId: nextStep._id,
        recipeExecutionNumber: task.recipeExecutionNumber, // SAME execution
        totalRecipeExecutions: task.totalRecipeExecutions,
        stepOrder: nextStep.order,
        isLastStepInRecipe: isNextStepLast,
        deviceTypeId: nextStep.deviceTypeId,
        status: "PENDING",
        priority: task.priority,
        estimatedDuration: nextStep.estimatedDuration,
        progress: 0,
        pausedDuration: 0
      });

      await nextTask.save();
    }

    // If this IS the last step, increment producedQuantity
    if (task.isLastStepInRecipe && task.projectId) {
      project = await Project.findById(task.projectId);
      if (project) {
        if (task.productId) {
          // Task is part of a product - complex calculation
          const productIndex = project.products.findIndex(
            (p: any) => p.productId.toString() === task.productId!.toString()
          );

          if (productIndex !== -1) {
            // Get product to find recipe quantity
            const product = await Product.findById(task.productId);
            if (product) {
              const productRecipe = product.recipes.find(
                (r: any) => r.recipeId.toString() === task.recipeId.toString()
              );

              if (productRecipe) {
                // Count how many executions of this recipe are completed
                const completedExecutions = await Task.countDocuments({
                  projectId: task.projectId,
                  productId: task.productId,
                  recipeId: task.recipeId,
                  isLastStepInRecipe: true,
                  status: "COMPLETED"
                });

                // Calculate completed product units
                const executionsPerUnit = productRecipe.quantity;
                const completedUnits = Math.floor(
                  completedExecutions / executionsPerUnit
                );
                project.products[productIndex].producedQuantity =
                  completedUnits;
              }
            }
          }
        } else {
          // Standalone recipe in project - direct increment
          const recipeIndex = project.recipes.findIndex(
            (r: any) => r.recipeId.toString() === task.recipeId.toString()
          );

          if (recipeIndex !== -1) {
            project.recipes[recipeIndex].producedQuantity += 1;
          }
        }

        await project.save(); // Progress auto-calculated by pre-save hook
      }
    }

    await task.populate("projectId workerId");

    const responseData: any = {
      completedTask: task,
      nextTask: nextTask || null,
      isLastStep: task.isLastStepInRecipe,
      executionInfo: {
        executionNumber: task.recipeExecutionNumber,
        totalExecutions: task.totalRecipeExecutions,
        isLastStepInRecipe: task.isLastStepInRecipe
      }
    };

    // Include project progress if available
    if (task.projectId && project) {
      responseData.project = {
        _id: project._id,
        progress: project.progress
      };
    }

    const response: APIResponse = {
      success: true,
      message: nextTask
        ? `Task completed. Next step created for execution ${task.recipeExecutionNumber}.`
        : task.isLastStepInRecipe
        ? `Recipe execution ${task.recipeExecutionNumber}/${task.totalRecipeExecutions} completed!`
        : "Task completed",
      data: responseData
    };

    res.json(response);
  } catch (error: any) {
    console.error("Complete task error:", error);
    const response: APIResponse = {
      success: false,
      error: "INTERNAL_SERVER_ERROR",
      message: error.message || "Internal server error"
    };
    res.status(500).json(response);
  }
};

/**
 * Get standalone tasks (tasks not associated with any project)
 * GET /api/tasks/standalone
 */
export const getStandaloneTasks = async (
  req: Request,
  res: Response
): Promise<void> => {
  try {
    const {
      status,
      deviceId,
      deviceTypeId,
      recipeId,
      workerId,
      page = 1,
      limit = 10
    } = req.query;

    // Build query for tasks without projectId
    const query: any = {
      projectId: { $exists: false }
    };

    // Apply filters
    if (status) query.status = status;
    if (deviceId) query.deviceId = deviceId;
    if (deviceTypeId) query.deviceTypeId = deviceTypeId;
    if (recipeId) query.recipeId = recipeId;
    if (workerId) query.workerId = workerId;

    const pageNum = parseInt(page as string);
    const limitNum = parseInt(limit as string);
    const skip = (pageNum - 1) * limitNum;

    const total = await Task.countDocuments(query);
    const tasks = await Task.find(query)
      .populate("recipeId", "name recipeNumber version")
      .populate("recipeSnapshotId", "name version steps")
      .populate("workerId", "name username")
      .populate("deviceTypeId", "name")
      .populate("deviceId", "name")
      .skip(skip)
      .limit(limitNum)
      .sort({ createdAt: -1 });

    const response: APIResponse = {
      success: true,
      message: "Standalone tasks retrieved successfully",
      data: {
        items: tasks,
        pagination: {
          page: pageNum,
          limit: limitNum,
          total,
          totalPages: Math.ceil(total / limitNum),
          hasNext: pageNum * limitNum < total,
          hasPrev: pageNum > 1
        }
      }
    };

    res.json(response);
  } catch (error) {
    console.error("Get standalone tasks error:", error);
    const response: APIResponse = {
      success: false,
      error: "INTERNAL_SERVER_ERROR",
      message: "Internal server error"
    };
    res.status(500).json(response);
  }
};
